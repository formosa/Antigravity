
## 2. Tier-by-Tier Boundary Definitions

### 2.1 BRD — Business Requirements Document

**Tier Position:** Layer 1 (Root)
**Answers:** "Why are we building this?"
**Persona:** Executive Strategist / Product Owner
**Scope:** Strategic objectives, business justification, stakeholder needs

#### Classification Criteria

**INCLUDE if information:**

1.  Describes the fundamental **business problem** being solved
2.  Defines **strategic objectives** independent of technical implementation
3.  Articulates **stakeholder value propositions**
4.  Establishes **success metrics** at the organizational level (uptime SLAs, user satisfaction)
5.  States **high-level scope** boundaries (what's in/out of MVP)
6.  Identifies **environmental/operational constraints** (offline requirement, privacy mandates)

**EXCLUDE if information:**

1.  Specifies technical architectures, patterns, or technologies
2.  Defines data structures, APIs, or protocols
3.  Describes implementation details or algorithms
4.  Contains hardware specifications beyond environmental context
5.  Provides numeric performance targets more granular than SLAs

#### Qualification Rubric
| Criterion | BRD-Appropriate | Not BRD-Appropriate |
|:--|:--|:--|
| **Abstraction Level** | "Enable privacy-preserving AI" | "Use local TCP sockets" |
| **Stakeholder Focus** | "End users require offline capability" | "Runtime process uses ONNX" |
| **Temporal Scope** | "Strategic objective for 2025-2026" | "Queue timeout = 100ms" |
| **Justification Type** | "Competitive advantage" | "Prevents memory leak" |
| **Success Measure** | "99.9% uptime SLA" | "<1ms dispatch latency" |

#### Real-World Examples

**Example 1: Strategic Objective (INCLUDE)**

> **Embedded Example Type:** reStructuredText BRD directive
~~~rst
.. brd:: Strategic Objective
   :id: BRD-2

   Enable responsive, privacy-preserving AI assistant capabilities
   without dependency on cloud infrastructure.
~~~

-   **Why BRD:** States a business-driven technology mandate (privacy, offline)
-   **Not Lower Tier:** Doesn't specify _how_ (multi-process, ZeroMQ)

**Example 2: Stakeholder Problem (INCLUDE)**

> **Embedded Example Type:** reStructuredText BRD directive
~~~rst
.. brd:: Problem Statement
   :id: BRD-4

   Users require AI assistant capabilities but are constrained by
   internet dependency, privacy concerns, and single-process limitations.

~~~

-   **Why BRD:** Describes the market/user pain point, not the solution
-   **Not Lower Tier:** Doesn't prescribe architecture

**Example 3: Incorrectly Classified (EXCLUDE)**

> **Embedded Example Type:** reStructuredText BRD directive
~~~rst
.. brd:: [BAD EXAMPLE]
   :id: BRD-X

   Use ZeroMQ ROUTER-DEALER pattern for IPC

~~~

-   **Why Not BRD:** This is a technical architecture decision (belongs in SAD)
-   **Correct Classification:** `SAD-1.1` :links: `BRD-5` (traces to "offline framework" scope)

**Example 4: Scope Boundary (INCLUDE)**

> **Embedded Example Type:** reStructuredText BRD directive
~~~rst
.. brd:: Local LLM, TTS, and STT inference.
   :id: BRD-5.2
   :links: BRD-5

~~~

-   **Why BRD:** Defines functional scope at the capability level
-   **Not Lower Tier:** Doesn't specify models, frameworks, or APIs

----------

### 2.2 NFR — Non-Functional Requirements

**Tier Position:** Layer 2
**Answers:** "Within what constraints must the system operate?"
**Persona:** Systems Administrator / Performance Engineer
**Scope:** Hardware limits, performance targets, reliability thresholds, security boundaries

#### Classification Criteria

**INCLUDE if information:**

1.  Specifies **hardware resource limits** (CPU model, VRAM capacity, RAM allocation)
2.  Defines **quantitative performance targets** (latency thresholds, throughput minimums)
3.  Establishes **reliability/availability requirements** (fault tolerance, uptime)
4.  States **security constraints** (network isolation, encryption requirements)
5.  Mandates **technology dependencies** (Python 3.11+, CUDA toolkit)
6.  Prescribes **resource utilization bounds** (max CPU %, memory footprints)

**EXCLUDE if information:**

1.  Describes business objectives or user value propositions
2.  Defines functional behavior or capabilities
3.  Specifies implementation details (class names, method signatures)
4.  Describes data schemas or message formats
5.  Provides architectural patterns (unless as constraints)

#### Qualification Rubric


| Criterion | NFR-Appropriate | Not NFR-Appropriate |
|:--|:--|:--|
| **Measurability** | "<1ms dispatch latency" | "Fast IPC communication" |
| **Constraint Type** | "RTX 3080 10GB VRAM limit" | "Use GPU for inference" |
| **Enforcement** | "No process shall block >5s" | "Core routes messages" |
| **Scope** | "All communication via 127.0.0.1" | "ROUTER binds to :5555" |
| **Invariance** | "Python >=3.11 required" | "Import zmq.Context" |

#### Real-World Examples

**Example 1: Hardware Constraint (INCLUDE)**

> **Embedded Example Type:** reStructuredText NFR directive
~~~rst
.. nfr:: **GPU:** RTX 3080 10GB VRAM (Runtime/Inference only).
   :id: NFR-1.2
   :links: NFR-1

~~~

-   **Why NFR:** Specifies non-negotiable hardware boundary
-   **Traces To:** `BRD-6.1` ("High-end consumer workstation")
-   **Downstream Impact:** TDD must design around 10GB VRAM limit

**Example 2: Performance Target (INCLUDE)**

> **Embedded Example Type:** reStructuredText NFR directive
~~~rst
.. nfr:: **IPC Dispatch:** Sub-millisecond (<1ms) for metadata-only messages.
   :id: NFR-4.1
   :links: NFR-4

~~~

-   **Why NFR:** Quantifiable performance requirement
-   **Traces To:** `BRD-8.1` ("Sub-250ms IPC dispatch")
-   **Downstream Impact:** SAD must choose non-blocking I/O patterns

**Example 3: Reliability Constraint (INCLUDE)**

> **Embedded Example Type:** reStructuredText NFR directive
~~~rst
.. nfr:: **Non-blocking:** No process shall block waiting for another during standard IPC.
   :id: NFR-5.1
   :links: NFR-5

~~~

-   **Why NFR:** Non-functional reliability requirement
-   **Traces To:** `BRD-3.4` ("Reduce downtime through multi-process isolation")
-   **Downstream Impact:** SAD mandates receiver threads + queues

**Example 4: Incorrectly Classified (EXCLUDE)**

> **Embedded Example Type:** reStructuredText NFR directive
~~~rst
.. nfr:: [BAD EXAMPLE]
   :id: NFR-X

   Core process routes messages between UI and Runtime

~~~

-   **Why Not NFR:** This describes functional behavior, not constraints
-   **Correct Classification:** `FSD-1.1` :links: `NFR-5.1` (constraint on blocking)

----------

### 2.3 FSD — Feature Specification Document

**Tier Position:** Layer 3
**Answers:** "What does the system do?"
**Persona:** Product Manager / Business Analyst
**Scope:** System capabilities, functional behavior, user-facing features, workflows

#### Classification Criteria

**INCLUDE if information:**

1.  Describes **user-observable capabilities** (voice interaction, wake word detection)
2.  Defines **system behaviors** in response to events (state transitions, error handling)
3.  Specifies **feature workflows** (audio pipeline stages, intent resolution)
4.  Articulates **functional responsibilities** per component (Core routes, Runtime infers)
5.  States **business logic rules** (only send wake word if Core is idle)
6.  Describes **data flows** at the conceptual level (Audio → Core → Runtime)

**EXCLUDE if information:**

1.  Specifies technical implementations (socket types, thread models)
2.  Defines data schemas, protocols, or message formats
3.  Describes class structures or method signatures
4.  Provides performance metrics or resource limits
5.  States business objectives without functional specifications

#### Qualification Rubric


| Criterion | FSD-Appropriate | Not FSD-Appropriate |
|:--|:--|:--|
| **Observability** | "UI reflects HSM state visually" | "UI uses PySide6 framework" |
| **Action Trigger** | "Wake word detection transitions to Active" | "Porcupine engine runs on CPU" |
| **Capability** | "System supports STT, TTS, LLM inference" | "Runtime uses ONNX Runtime GPU" |
| **Workflow** | "Audio → Core → Runtime → Core → UI" | "Messages use ROUTER-DEALER pattern" |
| **Business Rule** | "Only emit WAKE_WORD if Core is Idle" | "Check state via HSM trigger guard" |

#### Real-World Examples

**Example 1: Functional Capability (INCLUDE)**

> **Embedded Example Type:** reStructuredText FSD directive
~~~rst
.. fsd:: **STT:** Execute transcription using faster-whisper (ONNX) on audio buffers routed from Audio Service.
   :id: FSD-5.1
   :links: FSD-5

~~~

-   **Why FSD:** Describes what the system does (STT capability)
-   **Traces To:** `BRD-5.2` (Local STT inference), `NFR-1.2` (GPU constraint)
-   **Downstream:** SAD defines routing topology, ICD defines message schema

**Example 2: Behavioral Rule (INCLUDE)**

> **Embedded Example Type:** reStructuredText FSD directive
~~~rst
.. fsd:: **Constraint:** Must only send WAKE_WORD_DETECTED if Core is in idle state.
   :id: FSD-4.2
   :links: FSD-4

~~~

-   **Why FSD:** Specifies conditional functional behavior
-   **Traces To:** `BRD-5.6` (HSM orchestration)
-   **Downstream:** TDD implements state query mechanism

**Example 3: Workflow Definition (INCLUDE)**

> **Embedded Example Type:** reStructuredText FSD directive
~~~rst
.. fsd:: Intent Resolution (The "Brain")
   :id: FSD-8
   :links: BRD-5.6,FSD-1

.. fsd:: **Input Normalization:** Core accepts inputs (VOICE, CLI, GUI) as uniform text strings.
   :id: FSD-8.1
   :links: FSD-8

.. fsd:: **Fast Path:** IF input matches Registry Key → Execute immediately.
   :id: FSD-8.3
   :links: FSD-8

.. fsd:: **Slow Path:** IF no match → Forward to LLM Service.
   :id: FSD-8.4
   :links: FSD-8

~~~

-   **Why FSD:** Describes the decision-making workflow
-   **Traces To:** `BRD-5.6` (HSM orchestration)
-   **Downstream:** TDD defines `command_registry` structure

**Example 4: Incorrectly Classified (EXCLUDE)**

> **Embedded Example Type:** reStructuredText FSD directive
~~~rst
.. fsd:: [BAD EXAMPLE]
   :id: FSD-X

   Core uses zmq.ROUTER socket bound to tcp://127.0.0.1:5555

~~~

-   **Why Not FSD:** This is implementation detail (architecture/protocol)
-   **Correct Classification:** `SAD-3.2` (Integration Strategy) :links: `FSD-1.1` (routing capability)

----------

### 2.4 SAD — System Architecture Document

**Tier Position:** Layer 4
**Answers:** "How is the system structured?"
**Persona:** Software Architect / Systems Designer
**Scope:** Architectural patterns, component topology, integration strategies, design principles

#### Classification Criteria

**INCLUDE if information:**

1.  Defines **architectural patterns** (Hub-and-Spoke, Pub-Sub, Event-Driven)
2.  Specifies **component topology** (process diagrams, socket relationships)
3.  Describes **integration strategies** (Request-Response, Fire-and-Forget)
4.  Establishes **technology choices** for architectural concerns (ZeroMQ for IPC)
5.  Articulates **design principles** (no shared abstraction, configuration-driven)
6.  Defines **concurrency models** (receiver threads, priority queues)

**EXCLUDE if information:**

1.  Specifies exact data formats or schemas
2.  Provides class/method implementation details
3.  Defines business logic or functional workflows
4.  States performance targets (unless as design justification)
5.  Describes user-facing features

#### Qualification Rubric


| Criterion | SAD-Appropriate | Not SAD-Appropriate |
|:--|:--|:--|
| **Abstraction** | "Hub-and-Spoke topology" | "Core binds port 5555" | | **Pattern** | "ROUTER-DEALER for request-response" | "Metadata frame is JSON" |
| **Principle** | "No shared base class for patterns" | "Class ServiceClient extends ABC" |
| **Technology** | "ZeroMQ for non-blocking IPC" | "import zmq; ctx = zmq.Context()" |
| **Concurrency** | "Receiver threads + PriorityQueue" | "threading.Thread(target=_poll_loop)" |

#### Real-World Examples

**Example 1: Architectural Pattern (INCLUDE)**

> **Embedded Example Type:** reStructuredText SAD directive
~~~rst
.. sad:: **Hub-and-Spoke:** Core Process acts as central ROUTER (Hub); Services are DEALER (Spokes).
   :id: SAD-1.1
   :links: SAD-1

~~~

-   **Why SAD:** Defines the structural pattern
-   **Traces To:** `FSD-1.1` (Core routes messages)
-   **Downstream:** ICD defines frame structure, TDD implements sockets

**Example 2: Integration Strategy (INCLUDE)**

> **Embedded Example Type:** reStructuredText SAD directive
~~~rst
.. sad:: Integration Strategy
   :id: SAD-3
   :links: FSD-6.1,NFR-2.1,NFR-2

.. sad:: **Core ↔ Services (Request-Response):**
   :id: SAD-3.1
   :links: SAD-3

.. sad:: **Pattern:** ZeroMQ ROUTER (Core) ↔ DEALER (Service).
   :id: SAD-3.2
   :links: SAD-3

.. sad:: **All Processes → LogServer (Logging):**
   :id: SAD-3.5
   :links: SAD-3

.. sad:: **Pattern:** ZeroMQ PUSH → PULL.
   :id: SAD-3.6
   :links: SAD-3

~~~

-   **Why SAD:** Describes how components integrate
-   **Traces To:** `FSD-6.1` (distributed logging), `NFR-2.1` (local TCP only)
-   **Downstream:** ICD defines message frames, TDD configures sockets

**Example 3: Design Principle (INCLUDE)**

> **Embedded Example Type:** reStructuredText SAD directive
~~~rst
.. sad:: **No Shared Abstraction:** ROUTER-DEALER and PUSH-PULL patterns are implemented separately to avoid artificial coupling.
   :id: SAD-1.3
   :links: SAD-1

~~~

-   **Why SAD:** Articulates architectural decision rationale
-   **Traces To:** `NFR-5.1` (non-blocking requirement)
-   **Downstream:** TDD creates separate CoreProcess and ServiceClient classes

**Example 4: Concurrency Model (INCLUDE)**

> **Embedded Example Type:** reStructuredText SAD directive
~~~rst
.. sad:: Concurrency Model
   :id: SAD-4
   :links: NFR-5.1

.. sad:: **Receiver Threads:** Each process uses a dedicated thread to poll ZMQ sockets.
   :id: SAD-4.1
   :links: SAD-4

.. sad:: **Main Loop:** The main application loop processes the PriorityQueue.
   :id: SAD-4.2
   :links: SAD-4

~~~

-   **Why SAD:** Defines how concurrency is achieved architecturally
-   **Traces To:** `NFR-5.1` (no blocking on IPC)
-   **Downstream:** TDD specifies `_start_receiver_thread()` method

**Example 5: Topology Diagram (INCLUDE)**

> **Embedded Example Type:** reStructuredText SAD directive
~~~rst
.. sad:: Process Topology
   :id: SAD-2
   :links: FSD-1.1

   .. mermaid::

      graph LR
         Core["Core Process (ROUTER)"]
         UI["UI"] <==> Core
         Runtime["Runtime"] <==> Core
         Audio["Audio"] <==> Core

~~~

-   **Why SAD:** Visual representation of architectural structure
-   **Downstream:** TDD uses this to determine socket bindings per component

----------

### 2.5 ICD — Interface Control Document

**Tier Position:** Layer 5
**Answers:** "What are the data contracts?"
**Persona:** Data Engineer / Integration Specialist
**Scope:** Message schemas, configuration formats, protocol specifications, API contracts

#### Classification Criteria

**INCLUDE if information:**

1.  Defines **message schemas** (JSON structures, field types, validation rules)
2.  Specifies **configuration file formats** (YAML structure, required keys)
3.  Documents **protocol specifications** (frame ordering, header formats)
4.  Establishes **data validation rules** (mandatory fields, enum values)
5.  Describes **payload encoding** (UTF-8 text, binary PCM, multipart)
6.  Defines **API contracts** (request/response pairs, error codes)

**EXCLUDE if information:**

1.  Describes business logic or functional behavior
2.  Specifies class structures or implementation details
3.  Defines architectural patterns or topologies
4.  States performance requirements
5.  Provides code implementations


### Qualification Rubric

| Criterion | ICD-Appropriate | Not ICD-Appropriate |
|:--|:--|:--|
| **Data Shape** | `{"command": "string", "priority": 0\|1}` | "Messages are prioritized" |
| **Validation** | "request_id: UUID v4 format required" | "Generate UUID on send" |
| **Encoding** | "Payload: UTF-8 JSON or raw bytes" | "Parse JSON with json.loads()" |
| **Contract** | "Response echoes original request_id" | "Track request_id in dict" |
| **Protocol** | "Frame 0: Metadata, Frame 1+: Payload" | "Use send_multipart() method" |

#### Real-World Examples

**Example 1: Message Schema (INCLUDE)**

> **Embedded Example Type:** reStructuredText ICD directive
~~~rst
.. icd:: Metadata Schema (JSON)
   :id: ICD-3
   :links: FSD-6.3,SAD-4.7,SAD-4

   Every IPC message frame 0 (Metadata) must validate against:

   .. code-block:: json

      {
        "source": "UI | Audio | Runtime | Core",
        "destination": "Target_Service_Name",
        "command": "function_name_or_signal",
        "request_id": "uuid-v4-string",
        "timestamp": "ISO-8601-string",
        "priority": 0 | 1,
        "payload_type": "json | binary | text"
      }

~~~

-   **Why ICD:** Defines exact data structure and types
-   **Traces To:** `SAD-1.4` (context propagation), `SAD-4.7` (priority levels)
-   **Downstream:** TDD uses this schema for validation logic

**Example 2: Configuration Format (INCLUDE)**

> **Embedded Example Type:** reStructuredText ICD directive
~~~rst
.. icd:: IPC Configuration (ipc_config.yaml)
   :id: ICD-1
   :links: SAD-5.1,NFR-3.3,NFR-3.4,NFR-3.5,NFR-3.6,NFR-3

   .. code-block:: yaml

      core:
        router_bind: "tcp://127.0.0.1:5555"
        queue_maxsize: 1000
        response_timeout_s: 5.0

~~~

-   **Why ICD:** Specifies exact YAML structure and key names
-   **Traces To:** `SAD-5.1` (configuration-driven design), `NFR-3.3` (memory footprint)
-   **Downstream:** TDD implements `yaml.safe_load()` parsing

**Example 3: Frame Protocol (INCLUDE)**

> **Embedded Example Type:** reStructuredText ICD directive
~~~rst
.. icd:: Frame Structure
   :id: ICD-2
   :links: SAD-3.2,SAD-3.6,SAD-1.4,SAD-1

.. icd:: **Outbound (DEALER):** `[metadata_json, payload_bytes...]`
   :id: ICD-2.2
   :links: ICD-2

.. icd:: **Inbound (ROUTER):** `[service_identity, b'', metadata_json, payload_bytes...]`
   :id: ICD-2.3
   :links: ICD-2

~~~

-   **Why ICD:** Defines wire-level protocol format
-   **Traces To:** `SAD-3.2` (ROUTER-DEALER pattern)
-   **Downstream:** TDD implements frame parsing logic

**Example 4: Response Contract (INCLUDE)**

> **Embedded Example Type:** reStructuredText ICD directive
~~~rst
.. icd:: Response Payload Schema
   :id: ICD-4
   :links: ICD-3

   .. code-block:: json

      {
        "source": "Runtime",
        "destination": "UI",
        "status": "success | error",
        "error_code": "optional_string_or_null"
      }

~~~

-   **Why ICD:** Defines API contract for error handling
-   **Traces To:** `FSD-5.4` (error reporting), `FSD-7` (error handling)
-   **Downstream:** TDD implements response validation

----------

### 2.6 TDD — Technical Design Document

**Tier Position:** Layer 6
**Answers:** "What components implement the contracts?"
**Persona:** Lead Developer / Module Designer
**Scope:** Class structures, component blueprints, method signatures, dependency graphs

#### Classification Criteria

**INCLUDE if information:**

1.  Defines **class names and purposes** (`CoreProcess`, `ServiceClient`)
2.  Specifies **method signatures** (parameters, return types)
3.  Lists **component dependencies** (imported modules, libraries)
4.  Describes **internal data structures** (dicts, queues, state machines)
5.  Articulates **component responsibilities** (what each class must do)
6.  Maps **architectural patterns to implementation units** (receiver thread per process)

**EXCLUDE if information:**

1.  Provides actual implementation code (function bodies)
2.  Defines business logic workflows
3.  Specifies data schemas or message formats
4.  States performance targets or constraints
5.  Describes user-facing features

#### Qualification Rubric


| Criterion | TDD-Appropriate | Not TDD-Appropriate |
|:--|:--|:--|
| **Component** | "Class: CoreProcess" | "Core routes messages" |
| **Structure** | "active_requests: Dict\[str, Tuple\[bytes, float, str\]\]" | `{"req-123": (b'\x00\x01', 1234.56, "llm")}` |
| **Signature** | `send_request(cmd: str, payload: dict, priority: int)` | `self.dealer.send_multipart([meta, data])` |
| **Dependency** | "Import: zmq, queue, transitions" | `import zmq; ctx = zmq.Context()` |
| **Blueprint** | "Spawns receiver thread on init" | `threading.Thread(target=self._poll).start()` |

#### Real-World Examples

**Example 1: Component Blueprint (INCLUDE)**

> **Embedded Example Type:** reStructuredText TDD directive
~~~rst
.. tdd:: Component: CoreProcess
   :id: TDD-1
   :links: SAD-2,FSD-1.1

.. tdd:: **Class Name:** `CoreProcess`
   :id: TDD-1.1
   :links: TDD-1

.. tdd:: **Dependencies:** `zmq`, `queue`, `itertools`, `transitions`, `yaml`, `threading`.
   :id: TDD-1.2
   :links: TDD-1

.. tdd:: Bind `ROUTER` socket to address defined in `ipc_config.yaml`.
   :id: TDD-1.3
   :links: ICD-1,SAD-3.2,SAD-3

.. tdd:: Initialize `active_requests` dictionary: `Dict[str, Tuple[bytes, float, str]]`.
   :id: TDD-1.5
   :links: SAD-1.4,SAD-1

.. tdd:: **Receiver Thread:** Spawns a `threading.Thread` to poll the `ROUTER` socket.
   :id: TDD-1.7
   :links: SAD-4.1,SAD-4

~~~

-   **Why TDD:** Defines the class structure without implementation
-   **Traces To:** `SAD-2` (topology), `ICD-1` (config schema), `SAD-4.1` (receiver thread)
-   **Downstream:** ISP provides code stubs with `pass` statements

**Example 2: Method Signature (INCLUDE)**

> **Embedded Example Type:** reStructuredText TDD directive
~~~rst
.. tdd:: Method: send_to_service
   :id: TDD-1.M2
   :links: TDD-1,ICD-2.3

   .. code-block:: python

      send_to_service(service_identity: bytes, frames: list) -> None
      """
      Send multipart message to specific service using ROUTER envelope.
      Frame structure: [service_identity, b'', metadata_json, payload_bytes...]
      """

~~~

-   **Why TDD:** Defines interface without logic
-   **Traces To:** `ICD-2.3` (frame structure), `SAD-3.4` (routing table)
-   **Downstream:** ISP implements with actual ZMQ calls

**Example 3: Internal Structure (INCLUDE)**

> **Embedded Example Type:** reStructuredText TDD directive
~~~rst
.. tdd:: Internal `queue.PriorityQueue` populated by `_receiver_thread`.
   :id: TDD-2.6
   :links: SAD-4.1,SAD-4

.. tdd:: Ordering enforced via `(priority, itertools.count(), message)` tuple.
   :id: TDD-2.7
   :links: SAD-4.6

~~~

-   **Why TDD:** Specifies internal data structure design
-   **Traces To:** `SAD-4.5` (queue structure), `SAD-4.6` (FIFO ordering)
-   **Downstream:** ISP initializes queue in `__init__`

**Example 4: Incorrectly Classified (EXCLUDE)**

> **Embedded Example Code:** Python anti-pattern example
~~~python
# BAD: This is implementation code (belongs in ISP)
def send_log(self, level, message):
    metadata = json.dumps({"level": level, "timestamp": time.time()})
    self.log_push.send_multipart([metadata.encode(), message.encode()])

~~~

-   **Why Not TDD:** This is implementation code (belongs in ISP)
-   **Correct Classification:** `ISP-2` :links: `TDD-2` (stub with signature only)

----------

### 2.7 ISP — Implementation Stub Prompts

**Tier Position:** Layer 7 (Leaf)
**Answers:** "What code structure should I generate?"
**Persona:** Code Generator / AI Assistant
**Scope:** Python stub code, Numpy docstrings, structural scaffolding

#### Classification Criteria

**INCLUDE if information:**

1.  Provides **executable Python stubs** (class/method definitions with `pass`)
2.  Includes **Numpy-style docstrings** (parameters, returns, references)
3.  Contains **structural scaffolding** (imports, class hierarchy)
4.  Embeds **traceability markers** (`Ref: |TAG|` in docstrings)
5.  Specifies **implementation hints** (comments on next steps)
6.  Demonstrates **correct usage patterns** (example instantiation)

**EXCLUDE if information:**

1.  Provides complete, production-ready implementations
2.  Includes complex business logic (beyond stubs)
3.  Defines data schemas or architectural patterns
4.  States requirements or specifications

#### Qualification Rubric

| Criterion | ISP-Appropriate | Not ISP-Appropriate |
|:--|:--|:--|
| **Code State** | `def run(self): pass` | `def run(self): while True: ...` |
| **Documentation** | Numpy docstring with `Ref: |TAG|` | Inline comments only |
| **Completeness** | Structural skeleton | Fully implemented logic |
| **Guidance** | `# TODO: Implement timeout check` | Complete algorithm |
| **Traceability** | `Initialize. Ref: |TDD-1|` | |

#### Real-World Examples

**Example 1: Class Stub (INCLUDE)**

> **Embedded Example Code:** Python class stub
~~~python
# |ISP-1|: "Stub: Core Process"

import zmq
import yaml
import queue
from transitions import Machine

class CoreProcess:
    """
    Orchestrates IPC between services using ZeroMQ ROUTER pattern.

    Implements
    ----------
    |TDD-1|, |FSD-1|

    Attributes
    ----------
    active_requests : dict
        Maps request_id to (identity, timestamp, command)
    queue : PriorityQueue
        Internal message queue from receiver thread
    """

    def __init__(self, config_path: str):
        """
        Initialize ZMQ Context, bind ROUTER socket.

        Parameters
        ----------
        config_path : str
            Path to ipc_config.yaml (|ICD-1|)

        References
        ----------
        |TDD-1.3|, |SAD-5.1|
        """
        pass

    def run(self) -> None:
        """
        Main event loop. Process queue, check timeouts, drive HSM.

        References
        ----------
        |TDD-1.8|, |FSD-2|
        """
        pass

~~~

-   **Why ISP:** Provides executable scaffold with traceability
-   **Traces To:** All parent tiers via embedded tags
-   **Usage:** Developer runs, fills `pass` statements with logic

**Example 2: Method Stub with Implementation Hints (INCLUDE)**

> **Embedded Example Code:** Python method stub
~~~python
|ISP-2.3|:

def send_log(self, level: str, message: str, request_id: str = None) -> None:
    """
    Fire-and-forget log emission.

    Parameters
    ----------
    level : str
        One of: DEBUG, INFO, WARNING, ERROR, CRITICAL
    message : str
        Log message content
    request_id : str, optional
        UUID for correlation (|ICD-3|)

    Implementation Notes
    --------------------
    1. Construct metadata dict per |ICD-3| schema
    2. Serialize to JSON, encode to bytes
    3. Call self.log_push.send_multipart([metadata, message])
    4. Wrap in try-except for zmq.Again (non-blocking)

    References
    ----------
    |TDD-2.5|, |SAD-3.8|, |FSD-6.2|
    """
    pass

~~~

-   **Why ISP:** Provides clear implementation guidance
-   **Traces To:** TDD (signature), ICD (schema), SAD (HWM config)

**Example 3: Configuration-Driven Initialization (INCLUDE)**

> **Embedded Example Code:** Python class stub
~~~python
|ISP-3.1|:

class ServiceClient:
    def __init__(self, service_name: str, config_path: str):
        """
        Connect DEALER and PUSH sockets per configuration.

        Parameters
        ----------
        service_name : str
            One of: 'ui', 'runtime', 'audio'
        config_path : str
            Path to ipc_config.yaml

        Implementation Steps
        --------------------
        1. Load config: cfg = yaml.safe_load(open(config_path))
        2. Extract: self.cfg = cfg['services'][service_name]
        3. Create DEALER: self.dealer = ctx.socket(zmq.DEALER)
        4. Connect: self.dealer.connect(self.cfg['dealer_connect'])
        5. Create PUSH with SNDHWM=1, LINGER=0 (|SAD-3.8|)
        6. Start receiver thread: self._start_receiver_thread()

        References
        ----------
        |TDD-2.2|, |ICD-1|, |NFR-5.3|
        """
        pass

~~~

-   **Why ISP:** Step-by-step implementation roadmap
-   **Traces To:** Configuration schema, architectural constraints

----------
