
## 20. Advanced Integration Patterns

### 20.1 External System Integration Documentation

When MAGGIE integrates with external systems (APIs, databases, hardware), document the boundary contracts across all tiers.

#### Example: Home Automation Integration

**Business Requirement (BRD):**
> **Embedded Example Type:** reStructuredText BRD directive
~~~rst
.. brd:: Smart Home Control
   :id: BRD-16

   Enable voice control of home automation devices (lights, thermostats, locks) to position MAGGIE as a central home hub. Target: 40% of users connect ≥3 devices within first month.

   MARKET DIFFERENTIATION:
   - Offline operation (no cloud dependency for local devices)
   - Privacy-preserving (device state never leaves network)
   - Vendor-agnostic (Zigbee, Z-Wave, Matter protocols)
~~~

**Constraints (NFR):**
> **Embedded Example Type:** reStructuredText NFR directive
~~~rst
.. nfr:: Home Automation Constraints
   :id: NFR-16
   :links: BRD-16

.. nfr:: Protocol support: Zigbee 3.0, Z-Wave 700 series, Matter 1.0.
   :id: NFR-16.1
   :links: NFR-16

.. nfr:: Device discovery: <5s for 50 devices on local network.
   :id: NFR-16.2
   :links: NFR-16

.. nfr:: Command latency: <500ms from voice to device action.
   :id: NFR-16.3
   :links: NFR-16

.. nfr:: No internet dependency for local device control.
   :id: NFR-16.4
   :links: NFR-16

.. nfr:: Hardware: USB Zigbee/Z-Wave dongle required.
   :id: NFR-16.5
   :links: NFR-16

.. nfr:: Concurrent device commands: Support up to 10 simultaneous operations.
   :id: NFR-16.6
   :links: NFR-16
~~~

**Feature Specification (FSD):**
> **Embedded Example Type:** reStructuredText FSD directive
~~~rst
.. fsd:: Device Control Workflow
   :id: FSD-17
   :links: NFR-16

.. fsd:: User: "Turn on kitchen lights" → LLM extracts intent → Device command.
   :id: FSD-17.1
   :links: FSD-17

.. fsd:: LLM identifies: {action: "turn_on", device: "kitchen_lights"}.
   :id: FSD-17.2
   :links: FSD-17

.. fsd:: Core queries DeviceService for device ID matching "kitchen_lights".
   :id: FSD-17.3
   :links: FSD-17

.. fsd:: DeviceService sends Zigbee command to physical device.
   :id: FSD-17.4
   :links: FSD-17

.. fsd:: Device confirms state change → UI displays "Kitchen lights: ON".
   :id: FSD-17.5
   :links: FSD-17

.. fsd:: Error handling: "Device unreachable" spoken via TTS if timeout.
   :id: FSD-17.6
   :links: FSD-17

.. fsd:: Device discovery: On startup, scan network for compatible devices.
   :id: FSD-17.7
   :links: FSD-17

.. fsd:: User can rename devices via UI: "Living Room Lamp 1" → "Reading Light".
   :id: FSD-17.8
   :links: FSD-17
~~~

**Architecture (SAD):**
> **Embedded Example Type:** reStructuredText SAD directive
~~~rst
.. sad:: Home Automation Architecture
   :id: SAD-15
   :links: FSD-17

.. sad:: New Service: DeviceService (separate process, USB hardware access).
   :id: SAD-15.1
   :links: SAD-15

.. sad:: Pattern: Command-Query Separation (Commands: Async fire-and-forget; Queries: Sync request-response).
   :id: SAD-15.2
   :links: SAD-15

.. sad:: Device Registry: SQLite table mapping friendly_name → device_id → protocol.
   :id: SAD-15.3
   :links: SAD-15

.. sad:: Protocol Abstraction: Plugin architecture for Zigbee/Z-Wave/Matter.
   :id: SAD-15.4
   :links: SAD-15

.. sad:: Topology
   :id: SAD-15.5
   :links: SAD-15

   UI/Voice → Core → LLM (intent extraction)
               ↓
          Core → DeviceService → USB Dongle → Physical Device
               ↓
          Core → UI (state update)

.. sad:: Fault Tolerance: DeviceService crash does not affect Core/LLM.
   :id: SAD-15.6
   :links: SAD-15
~~~

**Data Contracts (ICD):**
> **Embedded Example Type:** reStructuredText ICD directive
~~~rst
.. icd:: Device Registry Schema (SQLite)
   :id: ICD-16
   :links: SAD-15.3

   .. code-block:: sql

      CREATE TABLE devices (
          device_id TEXT PRIMARY KEY,
          friendly_name TEXT NOT NULL,
          device_type TEXT,  -- 'light', 'thermostat', 'lock', etc.
          protocol TEXT,     -- 'zigbee', 'zwave', 'matter'
          protocol_address TEXT,  -- Device-specific ID (Zigbee EUI64, etc.)
          capabilities TEXT, -- JSON: {brightness: true, color: false, ...}
          room TEXT,         -- 'kitchen', 'bedroom', etc.
          last_seen TIMESTAMP
      );

.. icd:: Device Command Schema
   :id: ICD-17
   :links: FSD-17.2

   .. code-block:: json

      {
        "command": "device_control",
        "request_id": "uuid",
        "payload": {
          "device_id": "zigbee_bulb_001",
          "action": "turn_on" | "turn_off" | "set_brightness" | "set_color",
          "parameters": {
            "brightness": 75,
            "color": {"r": 255, "g": 200, "b": 150}
          }
        }
      }

.. icd:: Device State Update (Broadcast)
   :id: ICD-18
   :links: FSD-17.5

   .. code-block:: json

      {
        "command": "DEVICE_STATE_CHANGED",
        "priority": 1,
        "payload": {
          "device_id": "zigbee_bulb_001",
          "friendly_name": "Kitchen Lights",
          "state": {
            "power": "on",
            "brightness": 75,
            "reachable": true
          },
          "timestamp": "ISO-8601"
        }
      }
~~~

**Component Design (TDD):**
> **Embedded Example Type:** reStructuredText TDD directive
~~~rst
.. tdd:: Component: DeviceService
   :id: TDD-12
   :links: ICD-16, SAD-15

.. tdd:: Class: DeviceService (inherits ServiceClient)
   :id: TDD-12.1
   :links: TDD-12

.. tdd:: Dependencies: zigpy (Zigbee), python-openzwave (Z-Wave), pyserial
   :id: TDD-12.2
   :links: TDD-12

.. tdd:: Method: discover_devices() -> List[Device]
   :id: TDD-12.3
   :links: TDD-12

.. tdd:: Method: send_command(device_id: str, action: str, params: dict) -> bool
   :id: TDD-12.4
   :links: TDD-12

.. tdd:: Method: get_device_state(device_id: str) -> dict
   :id: TDD-12.5
   :links: TDD-12

.. tdd:: Internal: device_registry (SQLite connection)
   :id: TDD-12.6
   :links: TDD-12

.. tdd:: Internal: protocol_handlers (dict mapping 'zigbee' → ZigbeeHandler)
   :id: TDD-12.7
   :links: TDD-12

.. tdd:: Thread: device_monitor (polls devices every 30s)
   :id: TDD-12.8
   :links: TDD-12

.. tdd:: Component: ProtocolHandler (Abstract)
   :id: TDD-13
   :links: SAD-15.4

.. tdd:: Class: ProtocolHandler (ABC)
   :id: TDD-13.1
   :links: TDD-13

.. tdd:: Method: discover() -> List[Device]
   :id: TDD-13.2
   :links: TDD-13

.. tdd:: Method: send_command(address: str, action: str, params: dict)
   :id: TDD-13.3
   :links: TDD-13

.. tdd:: Method: get_state(address: str) -> dict
   :id: TDD-13.4
   :links: TDD-13

.. tdd:: Subclasses: ZigbeeHandler, ZWaveHandler, MatterHandler
   :id: TDD-13.5
   :links: TDD-13
~~~

**Implementation Stubs (ISP):**
> **Embedded Example Code:** Python class/stub
~~~python
# |ISP-11|: "Device Service Implementation Stubs"

import sqlite3
from typing import List, Dict
from abc import ABC, abstractmethod

class Device:
    """
    Device data model matching |ICD-16| schema.

    Attributes
    ----------
    device_id : str
        Unique identifier
    friendly_name : str
        User-assigned name
    protocol : str
        'zigbee', 'zwave', 'matter'
    capabilities : dict
        Supported actions/parameters
    """
    def __init__(self, device_id: str, friendly_name: str,
                 protocol: str, capabilities: dict):
        self.device_id = device_id
        self.friendly_name = friendly_name
        self.protocol = protocol
        self.capabilities = capabilities

class ProtocolHandler(ABC):
    """
    Abstract base for protocol-specific device communication.

    Implements
    ----------
    |TDD-13|, |SAD-15.4|

    Subclasses
    ----------
    ZigbeeHandler, ZWaveHandler, MatterHandler
    """

    @abstractmethod
    def discover(self) -> List[Device]:
        """
        Scan network for devices using this protocol.

        Returns
        -------
        List[Device]
            Discovered devices with populated metadata

        Performance
        -----------
        Must complete within 5s (|NFR-16.2|)

        References
        ----------
        |TDD-13.2|, |FSD-17.7|
        """
        pass

    @abstractmethod
    def send_command(self, address: str, action: str, params: dict) -> bool:
        """
        Send control command to physical device.

        Parameters
        ----------
        address : str
            Protocol-specific device address (e.g., Zigbee EUI64)
        action : str
            Command type from |ICD-17|
        params : dict
            Action parameters (brightness, color, etc.)

        Returns
        -------
        bool
            True if device acknowledged command

        Performance
        -----------
        Must complete within 500ms (|NFR-16.3|)

        References
        ----------
        |TDD-13.3|, |FSD-17.4|
        """
        pass

class DeviceService(ServiceClient):
    """
    Home automation device management service.

    Implements
    ----------
    |TDD-12|, |FSD-17|

    Constraints
    -----------
    |NFR-16.5|: Requires USB Zigbee/Z-Wave dongle

    Attributes
    ----------
    device_registry : sqlite3.Connection
        Local device database (|ICD-16|)
    protocol_handlers : Dict[str, ProtocolHandler]
        Protocol-specific communication handlers
    """

    def __init__(self, config_path: str, db_path: str, usb_port: str):
        """
        Initialize device service with hardware connection.

        Parameters
        ----------
        config_path : str
            Path to ipc_config.yaml
        db_path : str
            Path to devices.db
        usb_port : str
            Serial port for USB dongle (e.g., '/dev/ttyUSB0')

        Implementation Notes
        --------------------
        1. Call super().__init__("device", config_path)
        2. Connect to device registry database
        3. Initialize protocol handlers:
           - ZigbeeHandler(usb_port) if dongle supports Zigbee
           - ZWaveHandler(usb_port) if dongle supports Z-Wave
        4. Start device_monitor thread (|TDD-12.8|)

        References
        ----------
        |TDD-12.2|, |NFR-16.5|
        """
        super().__init__("device", config_path)
        pass

    def discover_devices(self) -> List[Device]:
        """
        Scan network for all compatible devices.

        Returns
        -------
        List[Device]
            All discovered devices across all protocols

        Implementation Notes
        --------------------
        1. For each protocol_handler in self.protocol_handlers.values():
           a. devices = handler.discover()
           b. For each device:
              - Check if already in registry (by protocol_address)
              - If new: INSERT INTO devices
              - If exists: UPDATE last_seen
           c. Aggregate all devices
        2. Return combined list

        Performance
        -----------
        Parallelizable: Run protocol.discover() in separate threads
        Total time <5s for 50 devices (|NFR-16.2|)

        References
        ----------
        |TDD-12.3|, |FSD-17.7|
        """
        pass

    def send_command(self, device_id: str, action: str, params: dict) -> bool:
        """
        Execute device control command.

        Parameters
        ----------
        device_id : str
            Device identifier from registry
        action : str
            Command type (|ICD-17|)
        params : dict
            Action parameters

        Returns
        -------
        bool
            True if command succeeded

        Implementation Notes
        --------------------
        1. Query registry: SELECT protocol, protocol_address WHERE device_id = ?
        2. Get handler: handler = self.protocol_handlers[protocol]
        3. Execute: success = handler.send_command(address, action, params)
        4. If success:
           a. Broadcast DEVICE_STATE_CHANGED (|ICD-18|)
           b. Log command execution
        5. Return success status

        Error Handling
        --------------
        - Device unreachable: Broadcast error, return False
        - Invalid action: Log warning, return False

        References
        ----------
        |TDD-12.4|, |FSD-17.4|, |FSD-17.6|
        """
        pass
~~~

----------

### 20.2 Plugin Architecture Documentation

For extensible systems like MAGGIE's Tool/Routine framework, document the plugin contract.

**Plugin Lifecycle Specification:**
> **Embedded Example Type:** reStructuredText FSD directive
~~~rst
.. fsd:: Extension Lifecycle Management
   :id: FSD-18
   :links: BRD-5.3

.. fsd:: Discovery: Core scans ./extensions/ on startup.
   :id: FSD-18.1
   :links: FSD-18

.. fsd:: Validation: Each extension must have valid manifest.yaml.
   :id: FSD-18.2
   :links: FSD-18

.. fsd:: Loading: Core imports entry_point module via importlib.
   :id: FSD-18.3
   :links: FSD-18

.. fsd:: Initialization: Core calls extension.initialize(core_context).
   :id: FSD-18.4
   :links: FSD-18

.. fsd:: HSM Integration: Core merges extension.get_hsm_states() into main HSM.
   :id: FSD-18.5
   :links: FSD-18

.. fsd:: Error Isolation: Extension crash does not halt Core (logged as ERROR).
   :id: FSD-18.6
   :links: FSD-18

.. fsd:: Unloading: Extensions can be disabled via config (hot-reload not supported in MVP).
   :id: FSD-18.7
   :links: FSD-18
~~~

**Plugin Contract (ICD):**
> **Embedded Example Type:** reStructuredText ICD directive
~~~rst
.. icd:: Extension Manifest Schema
   :id: ICD-19
   :links: FSD-18.2

   .. code-block:: yaml

      # File: ./extensions/my_tool/manifest.yaml
      name: "my_tool"              # Unique identifier (required)
      version: "1.0.0"             # Semantic version (required)
      type: "tool" | "routine"     # Extension type (required)
      entry_point: "src.plugin"    # Python module path (required)
      dependencies:                # Optional: External pip packages
        - "requests>=2.28.0"
        - "beautifulsoup4"
      requires_services:           # Optional: Service process dependencies
        - "runtime"                # Requires Runtime for LLM calls
        - "ui"                     # Requires UI for user interaction
      metadata:                    # Optional: Display info
        author: "Developer Name"
        description: "Brief description"
        license: "MIT"
~~~

**Plugin Base Class (TDD):**
> **Embedded Example Code:** Python class
~~~python
# |TDD-14|: "Extension Base Class Design"

from abc import ABC, abstractmethod
from typing import List, Dict, Any

class AbstractExtension(ABC):
    """
    Base class for all Tools and Routines.

    Implements
    ----------
    |TDD-14|, |FSD-3|

    Lifecycle
    ---------
    1. Core instantiates: ext = ExtensionClass()
    2. Core initializes: ext.initialize(core_context)
    3. Core queries: states = ext.get_hsm_states()
    4. Core registers: ext event handlers with HSM

    Attributes
    ----------
    core_context : CoreContext
        Injected dependency for Core services
    """

    @abstractmethod
    def initialize(self, core_context: Any) -> None:
        """
        Called once during Core startup.

        Parameters
        ----------
        core_context : CoreContext
            Provides access to:
            - core_context.send_to_service(service, command, payload)
            - core_context.logger (Loguru instance)
            - core_context.config (Dict from ipc_config.yaml)

        Implementation Notes
        --------------------
        - Load extension-specific configuration
        - Initialize internal state
        - Validate required services are available

        Raises
        ------
        RuntimeError
            If required service not available

        References
        ----------
        |FSD-18.4|, |TDD-4.2|
        """
        pass

    @abstractmethod
    def get_hsm_states(self) -> List[Dict[str, Any]]:
        """
        Return HSM state definitions for dynamic compilation.

        Returns
        -------
        List[Dict]
            State configuration dicts for transitions library

        Schema
        ------
        [
          {
            "name": "state_name",
            "parent": "busy",
            "on_enter": "method_name",
            "on_exit": "method_name"
          },
          ...
        ]

        References
        ----------
        |FSD-18.5|, |FSD-2.2|, |TDD-4.3|
        """
        pass

    @abstractmethod
    def handle_event(self, event_data: Dict[str, Any]) -> str:
        """
        Process business logic for extension-specific events.

        Parameters
        ----------
        event_data : dict
            Event payload from Core

        Returns
        -------
        str
            Next HSM trigger to fire (e.g., "to_idle", "to_error")

        Implementation Notes
        --------------------
        - Inspect event_data["event_type"]
        - Execute tool/routine logic
        - Call core_context.send_to_service() for IPC
        - Return appropriate HSM trigger

        References
        ----------
        |FSD-18.6|, |TDD-4.4|
        """
        pass
~~~

----------

### 20.3 Performance Profiling Documentation

When optimizing performance, document both targets and measurement methodology.

**Performance Requirements (NFR):**
> **Embedded Example Type:** reStructuredText NFR directive
~~~rst
.. nfr:: Performance Profiling & Optimization
   :id: NFR-17
   :links: BRD-8

.. nfr:: Instrumentation overhead: <1% CPU, <10MB RAM.
   :id: NFR-17.1
   :links: NFR-17

.. nfr:: Metrics collection frequency: Every 100ms (non-blocking).
   :id: NFR-17.2
   :links: NFR-17

.. nfr:: Metrics storage: Rolling buffer, last 1 hour of data.
   :id: NFR-17.3
   :links: NFR-17

.. nfr:: Metrics visualization: Real-time dashboard (optional UI tab).
   :id: NFR-17.4
   :links: NFR-17

.. nfr:: Exportable reports: JSON export for offline analysis.
   :id: NFR-17.5
   :links: NFR-17
~~~

**Profiling Features (FSD):**
> **Embedded Example Type:** reStructuredText FSD directive
~~~rst
.. fsd:: Performance Monitoring
   :id: FSD-19
   :links: NFR-17

.. fsd:: Core tracks per-request latency breakdown: IPC routing, Service processing, Queue wait.
   :id: FSD-19.1
   :links: FSD-19

.. fsd:: Services report GPU/CPU utilization every 100ms.
   :id: FSD-19.2
   :links: FSD-19

.. fsd:: Memory profiler tracks per-process RSS/VRAM usage.
   :id: FSD-19.3
   :links: FSD-19

.. fsd:: UI displays real-time metrics: FPS, tokens/second, buffer health.
   :id: FSD-19.4
   :links: FSD-19

.. fsd:: Admin command: "/metrics export" → saves JSON to ./logs/metrics_{timestamp}.json.
   :id: FSD-19.5
   :links: FSD-19
~~~

**Metrics Schema (ICD):**
> **Embedded Example Type:** reStructuredText ICD directive
~~~rst
.. icd:: Performance Metrics Schema
   :id: ICD-20
   :links: FSD-19.1

   .. code-block:: json

      {
        "timestamp": "ISO-8601",
        "request_id": "uuid",
        "latency_breakdown": {
          "total_ms": 1234.5,
          "ipc_routing_ms": 2.1,
          "stt_processing_ms": 450.0,
          "llm_inference_ms": 780.0,
          "tts_synthesis_ms": 2.4
        },
        "resource_usage": {
          "core_process": {"cpu_percent": 5.2, "rss_mb": 45},
          "runtime_process": {"cpu_percent": 85.0, "rss_mb": 3200, "vram_mb": 4800},
          "ui_process": {"cpu_percent": 12.0, "rss_mb": 180}
        },
        "queue_stats": {
          "core_queue_size": 3,
          "runtime_queue_size": 1,
          "max_wait_time_ms": 15.0
        }
      }
~~~

----------
