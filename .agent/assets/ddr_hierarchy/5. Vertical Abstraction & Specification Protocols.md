
## 5. Vertical Abstraction & Specification Protocols

### 5.1 Upward Abstraction (Child → Parent)

When an orphaned specification exists without a parent requirement, synthesize the parent by extracting the **strategic intent** or **constraint boundary**.

#### Protocol Steps

1.  **Identify the Essence:** Strip implementation details, preserve the "why" or "what limit"
2.  **Elevate Abstraction:** Transform technical specifics into business/constraint language
3.  **Validate Scope:** Ensure parent tier encompasses multiple potential child implementations
4.  **Check Redundancy:** Verify parent doesn't duplicate existing tags

#### Example 1: TDD → SAD Abstraction

**Orphaned Child (TDD):**

```
|TDD-1.7|: "Concurrency: Spawns receiver thread to poll ROUTER socket."

```

**Abstraction Process:**

-   **Technical Detail:** "Spawns receiver thread"
-   **Architectural Pattern:** "Non-blocking I/O via background polling"
-   **Constraint Context:** Must avoid blocking main loop (traces to NFR-5.1)

**Synthesized Parent (SAD):**

```
|SAD-4.1| ← |NFR-5.1|: "Receiver Threads: Each process uses dedicated
thread to poll ZMQ sockets and push to internal PriorityQueue."

```

**Validation:**

-   ✅ Covers multiple implementations (Core, UI, Runtime, Audio)
-   ✅ Describes architectural mechanism, not specific code
-   ✅ Cites constraint that mandates the pattern

#### Example 2: FSD → BRD Abstraction

**Orphaned Child (FSD):**

```
|FSD-4.1|: "Wake Word: Always-on detection using pvporcupine."

```

**Abstraction Process:**

-   **Functional Spec:** "Wake word detection"
-   **User Value:** "Hands-free voice activation"
-   **Business Objective:** "Enable natural voice interaction"

**Synthesized Parent (BRD):**

```
|BRD-5.7|: "Voice Activation: Enable hands-free voice interaction for
accessibility and user convenience."

```

**Validation:**

-   ✅ Technology-agnostic (doesn't specify pvporcupine)
-   ✅ Focuses on business value, not implementation
-   ✅ Supports multiple potential wake word technologies

#### Example 3: ICD → SAD Abstraction

**Orphaned Child (ICD):**

```json
|ICD-2.2|: "Outbound (DEALER): [metadata_json, payload_bytes...]"

```

**Abstraction Process:**

-   **Protocol Detail:** "Metadata + payload frame structure"
-   **Integration Pattern:** "Request-response messaging"
-   **Architectural Choice:** "ZeroMQ DEALER socket pattern"

**Synthesized Parent (SAD):**

```
|SAD-3.2| ← |FSD-1.1|: "Pattern: ZeroMQ ROUTER (Core) ↔ DEALER (Service)
for bidirectional request-response messaging."

```

**Validation:**

-   ✅ Defines the architectural pattern enabling the protocol
-   ✅ Justifies why frame structure exists (DEALER requirements)
-   ✅ Traces to functional requirement (Core routing)

### 5.2 Downward Specification (Parent → Child)

When a high-level requirement lacks implementation details, decompose it by extracting **concrete mechanisms** or **technical constraints**.

#### Protocol Steps

1.  **Identify Implementation Vectors:** What specific technologies/patterns enable this?
2.  **Extract Measurables:** Convert qualitative goals to quantitative specs
3.  **Partition by Concern:** Separate architecture, data, and code aspects
4.  **Maintain Traceability:** Cite parent tag in all derived children

#### Example 1: BRD → NFR Specification

**Orphaned Parent (BRD):**

```
|BRD-8.1|: "Latency: Sub-250ms IPC dispatch; <1s LLM response."

```

**Specification Process:**

-   **Implied Constraints:** System must use non-blocking I/O
-   **Hardware Requirements:** Need fast CPU for IPC, GPU for LLM
-   **Measurable Targets:** Break down into component-level latencies

**Synthesized Children (NFR):**

```
|NFR-4| ← |BRD-8.1|: "Latency & Throughput"
  |NFR-4.1|: "IPC Dispatch: Sub-millisecond (<1ms) for metadata-only."
  |NFR-4.2|: "Round Trip: <5ms metadata; <20ms for 1MB payload."
  |NFR-4.3|: "LLM Inference: <1s average response time."

```

**Validation:**

-   ✅ All children trace to parent
-   ✅ Quantifies ambiguous "sub-250ms" into specific component budgets
-   ✅ Adds granularity (metadata vs payload latency)

#### Example 2: NFR → SAD Specification

**Orphaned Parent (NFR):**

```
|NFR-5.1|: "No process shall block waiting for another during IPC."

```

**Specification Process:**

-   **Architectural Implication:** Need asynchronous messaging
-   **Pattern Selection:** ZeroMQ with dedicated receiver threads
-   **Data Structure:** Internal queues to decouple I/O from logic

**Synthesized Children (SAD):**

```
|SAD-4| ← |NFR-5.1|: "Concurrency Model"
  |SAD-4.1|: "Receiver Threads: Dedicated thread polls ZMQ sockets."
  |SAD-4.2|: "Main Loop: Processes PriorityQueue (non-blocking)."
  |SAD-4.3|: "Queueing: Must use queue.PriorityQueue."

```

**Validation:**

-   ✅ Translates constraint into concrete architectural decisions
-   ✅ Specifies mechanism that enforces parent requirement
-   ✅ Enables multiple implementations (Core, Services)

#### Example 3: FSD → ICD Specification

**Orphaned Parent (FSD):**

```
|FSD-6.3|: "Correlation: All logs must include request_id."

```

**Specification Process:**

-   **Data Requirement:** request_id field in log metadata
-   **Format Constraint:** Must be UUID v4 format
-   **Protocol Rule:** Must be propagated in every IPC frame

**Synthesized Children (ICD):**

```
|ICD-3| ← |FSD-6.3|: "Metadata Schema (JSON)"
{
  "request_id": "uuid-v4-string",  // REQUIRED
  ...
}

|ICD-2.5| ← |FSD-6.3|: "Log Frame: [metadata_json, message_string]"
// Metadata MUST include request_id from originating event

```

**Validation:**

-   ✅ Defines exact data structure to implement feature
-   ✅ Specifies format constraint (UUID v4)
-   ✅ Covers all message types (IPC and logging)

### 5.3 Lateral Expansion (Sibling Generation)

When a tag exists in isolation but implies peer requirements, generate siblings by identifying **parallel concerns** at the same abstraction level.

#### Example: Generating FSD Siblings

**Existing Singleton:**

```
|FSD-7.1|: "LogServer Fault: Senders continue, drop logs silently."

```

**Implied Parallel Concerns:**

-   What about UI/Runtime/Audio faults?
-   What about Core faults?
-   What about timeout scenarios?

**Generated Siblings:**

```
|FSD-7| ← |BRD-2|, |NFR-5|: "Error Handling Strategy"
  |FSD-7.1|: "LogServer Fault: Senders continue, drop logs silently."
  |FSD-7.2|: "Service Fault: Core detects, marks unavailable, error state."
  |FSD-7.3|: "Timeout: Core detects non-response >5s, triggers error."
  |FSD-7.4|: "Core Fault: Services disconnect, attempt reconnect."

```

**Validation:**

-   ✅ All siblings address fault tolerance at same abstraction (behavior)
-   ✅ Comprehensive coverage of failure modes
-   ✅ Uniform citation of parent requirements

----------
