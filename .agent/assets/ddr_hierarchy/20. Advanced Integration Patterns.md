
## 20. Advanced Integration Patterns

### 20.1 External System Integration Documentation

When MAGGIE integrates with external systems (APIs, databases, hardware), document the boundary contracts across all tiers.

#### Example: Home Automation Integration

**Business Requirement (BRD):**

```
|BRD-16|: "Smart Home Control"
Enable voice control of home automation devices (lights, thermostats, locks)
to position MAGGIE as a central home hub. Target: 40% of users connect ≥3 devices
within first month.

MARKET DIFFERENTIATION:
- Offline operation (no cloud dependency for local devices)
- Privacy-preserving (device state never leaves network)
- Vendor-agnostic (Zigbee, Z-Wave, Matter protocols)

```

**Constraints (NFR):**

```
|NFR-16| ← |BRD-16|: "Home Automation Constraints"
  |NFR-16.1|: Protocol support: Zigbee 3.0, Z-Wave 700 series, Matter 1.0.
  |NFR-16.2|: Device discovery: <5s for 50 devices on local network.
  |NFR-16.3|: Command latency: <500ms from voice to device action.
  |NFR-16.4|: No internet dependency for local device control.
  |NFR-16.5|: Hardware: USB Zigbee/Z-Wave dongle required.
  |NFR-16.6|: Concurrent device commands: Support up to 10 simultaneous operations.

```

**Feature Specification (FSD):**

```
|FSD-17| ← |NFR-16|: "Device Control Workflow"
  |FSD-17.1|: User: "Turn on kitchen lights" → LLM extracts intent → Device command.
  |FSD-17.2|: LLM identifies: {action: "turn_on", device: "kitchen_lights"}.
  |FSD-17.3|: Core queries DeviceService for device ID matching "kitchen_lights".
  |FSD-17.4|: DeviceService sends Zigbee command to physical device.
  |FSD-17.5|: Device confirms state change → UI displays "Kitchen lights: ON".
  |FSD-17.6|: Error handling: "Device unreachable" spoken via TTS if timeout.
  |FSD-17.7|: Device discovery: On startup, scan network for compatible devices.
  |FSD-17.8|: User can rename devices via UI: "Living Room Lamp 1" → "Reading Light".

```

**Architecture (SAD):**

```
|SAD-15| ← |FSD-17|: "Home Automation Architecture"
  |SAD-15.1|: New Service: DeviceService (separate process, USB hardware access).
  |SAD-15.2|: Pattern: Command-Query Separation
    - Commands: Async fire-and-forget (turn_on, set_temperature)
    - Queries: Sync request-response (get_state, list_devices)
  |SAD-15.3|: Device Registry: SQLite table mapping friendly_name → device_id → protocol.
  |SAD-15.4|: Protocol Abstraction: Plugin architecture for Zigbee/Z-Wave/Matter.
  |SAD-15.5|: Topology:

    UI/Voice → Core → LLM (intent extraction)
                ↓
           Core → DeviceService → USB Dongle → Physical Device
                ↓
           Core → UI (state update)

  |SAD-15.6|: Fault Tolerance: DeviceService crash does not affect Core/LLM.

```

**Data Contracts (ICD):**

```json
|ICD-16| ← |SAD-15.3|: "Device Registry Schema (SQLite)"
CREATE TABLE devices (
    device_id TEXT PRIMARY KEY,
    friendly_name TEXT NOT NULL,
    device_type TEXT,  -- 'light', 'thermostat', 'lock', etc.
    protocol TEXT,     -- 'zigbee', 'zwave', 'matter'
    protocol_address TEXT,  -- Device-specific ID (Zigbee EUI64, etc.)
    capabilities TEXT, -- JSON: {brightness: true, color: false, ...}
    room TEXT,         -- 'kitchen', 'bedroom', etc.
    last_seen TIMESTAMP
);

|ICD-17| ← |FSD-17.2|: "Device Command Schema"
{
  "command": "device_control",
  "request_id": "uuid",
  "payload": {
    "device_id": "zigbee_bulb_001",
    "action": "turn_on" | "turn_off" | "set_brightness" | "set_color",
    "parameters": {
      "brightness": 75,  // 0-100, optional
      "color": {"r": 255, "g": 200, "b": 150}  // RGB, optional
    }
  }
}

|ICD-18| ← |FSD-17.5|: "Device State Update (Broadcast)"
{
  "command": "DEVICE_STATE_CHANGED",
  "priority": 1,
  "payload": {
    "device_id": "zigbee_bulb_001",
    "friendly_name": "Kitchen Lights",
    "state": {
      "power": "on",
      "brightness": 75,
      "reachable": true
    },
    "timestamp": "ISO-8601"
  }
}

```

**Component Design (TDD):**

```
|TDD-12| ← |ICD-16|, |SAD-15|: "Component: DeviceService"
  |TDD-12.1|: Class: DeviceService (inherits ServiceClient)
  |TDD-12.2|: Dependencies: zigpy (Zigbee), python-openzwave (Z-Wave), pyserial
  |TDD-12.3|: Method: discover_devices() -> List[Device]
  |TDD-12.4|: Method: send_command(device_id: str, action: str, params: dict) -> bool
  |TDD-12.5|: Method: get_device_state(device_id: str) -> dict
  |TDD-12.6|: Internal: device_registry (SQLite connection)
  |TDD-12.7|: Internal: protocol_handlers (dict mapping 'zigbee' → ZigbeeHandler)
  |TDD-12.8|: Thread: device_monitor (polls devices every 30s for state changes)

|TDD-13| ← |SAD-15.4|: "Component: ProtocolHandler (Abstract)"
  |TDD-13.1|: Class: ProtocolHandler (ABC)
  |TDD-13.2|: Method: discover() -> List[Device]
  |TDD-13.3|: Method: send_command(address: str, action: str, params: dict)
  |TDD-13.4|: Method: get_state(address: str) -> dict
  |TDD-13.5|: Subclasses: ZigbeeHandler, ZWaveHandler, MatterHandler

```

**Implementation Stubs (ISP):**

```python
|ISP-11| ← |TDD-12|:

import sqlite3
from typing import List, Dict
from abc import ABC, abstractmethod

class Device:
    """
    Device data model matching |ICD-16| schema.

    Attributes
    ----------
    device_id : str
        Unique identifier
    friendly_name : str
        User-assigned name
    protocol : str
        'zigbee', 'zwave', 'matter'
    capabilities : dict
        Supported actions/parameters
    """
    def __init__(self, device_id: str, friendly_name: str,
                 protocol: str, capabilities: dict):
        self.device_id = device_id
        self.friendly_name = friendly_name
        self.protocol = protocol
        self.capabilities = capabilities

class ProtocolHandler(ABC):
    """
    Abstract base for protocol-specific device communication.

    Implements
    ----------
    |TDD-13|, |SAD-15.4|

    Subclasses
    ----------
    ZigbeeHandler, ZWaveHandler, MatterHandler
    """

    @abstractmethod
    def discover(self) -> List[Device]:
        """
        Scan network for devices using this protocol.

        Returns
        -------
        List[Device]
            Discovered devices with populated metadata

        Performance
        -----------
        Must complete within 5s (|NFR-16.2|)

        References
        ----------
        |TDD-13.2|, |FSD-17.7|
        """
        pass

    @abstractmethod
    def send_command(self, address: str, action: str, params: dict) -> bool:
        """
        Send control command to physical device.

        Parameters
        ----------
        address : str
            Protocol-specific device address (e.g., Zigbee EUI64)
        action : str
            Command type from |ICD-17|
        params : dict
            Action parameters (brightness, color, etc.)

        Returns
        -------
        bool
            True if device acknowledged command

        Performance
        -----------
        Must complete within 500ms (|NFR-16.3|)

        References
        ----------
        |TDD-13.3|, |FSD-17.4|
        """
        pass

class DeviceService(ServiceClient):
    """
    Home automation device management service.

    Implements
    ----------
    |TDD-12|, |FSD-17|

    Constraints
    -----------
    |NFR-16.5|: Requires USB Zigbee/Z-Wave dongle

    Attributes
    ----------
    device_registry : sqlite3.Connection
        Local device database (|ICD-16|)
    protocol_handlers : Dict[str, ProtocolHandler]
        Protocol-specific communication handlers
    """

    def __init__(self, config_path: str, db_path: str, usb_port: str):
        """
        Initialize device service with hardware connection.

        Parameters
        ----------
        config_path : str
            Path to ipc_config.yaml
        db_path : str
            Path to devices.db
        usb_port : str
            Serial port for USB dongle (e.g., '/dev/ttyUSB0')

        Implementation Notes
        --------------------
        1. Call super().__init__("device", config_path)
        2. Connect to device registry database
        3. Initialize protocol handlers:
           - ZigbeeHandler(usb_port) if dongle supports Zigbee
           - ZWaveHandler(usb_port) if dongle supports Z-Wave
        4. Start device_monitor thread (|TDD-12.8|)

        References
        ----------
        |TDD-12.2|, |NFR-16.5|
        """
        super().__init__("device", config_path)
        pass

    def discover_devices(self) -> List[Device]:
        """
        Scan network for all compatible devices.

        Returns
        -------
        List[Device]
            All discovered devices across all protocols

        Implementation Notes
        --------------------
        1. For each protocol_handler in self.protocol_handlers.values():
           a. devices = handler.discover()
           b. For each device:
              - Check if already in registry (by protocol_address)
              - If new: INSERT INTO devices
              - If exists: UPDATE last_seen
           c. Aggregate all devices
        2. Return combined list

        Performance
        -----------
        Parallelizable: Run protocol.discover() in separate threads
        Total time <5s for 50 devices (|NFR-16.2|)

        References
        ----------
        |TDD-12.3|, |FSD-17.7|
        """
        pass

    def send_command(self, device_id: str, action: str, params: dict) -> bool:
        """
        Execute device control command.

        Parameters
        ----------
        device_id : str
            Device identifier from registry
        action : str
            Command type (|ICD-17|)
        params : dict
            Action parameters

        Returns
        -------
        bool
            True if command succeeded

        Implementation Notes
        --------------------
        1. Query registry: SELECT protocol, protocol_address WHERE device_id = ?
        2. Get handler: handler = self.protocol_handlers[protocol]
        3. Execute: success = handler.send_command(address, action, params)
        4. If success:
           a. Broadcast DEVICE_STATE_CHANGED (|ICD-18|)
           b. Log command execution
        5. Return success status

        Error Handling
        --------------
        - Device unreachable: Broadcast error, return False
        - Invalid action: Log warning, return False

        References
        ----------
        |TDD-12.4|, |FSD-17.4|, |FSD-17.6|
        """
        pass

```

----------

### 20.2 Plugin Architecture Documentation

For extensible systems like MAGGIE's Tool/Routine framework, document the plugin contract.

**Plugin Lifecycle Specification:**

```
|FSD-18| ← |BRD-5.3|: "Extension Lifecycle Management"
  |FSD-18.1|: Discovery: Core scans ./extensions/ on startup.
  |FSD-18.2|: Validation: Each extension must have valid manifest.yaml.
  |FSD-18.3|: Loading: Core imports entry_point module via importlib.
  |FSD-18.4|: Initialization: Core calls extension.initialize(core_context).
  |FSD-18.5|: HSM Integration: Core merges extension.get_hsm_states() into main HSM.
  |FSD-18.6|: Error Isolation: Extension crash does not halt Core (logged as ERROR).
  |FSD-18.7|: Unloading: Extensions can be disabled via config (hot-reload not supported in MVP).

```

**Plugin Contract (ICD):**

```yaml
|ICD-19| ← |FSD-18.2|: "Extension Manifest Schema"
# File: ./extensions/my_tool/manifest.yaml
name: "my_tool"              # Unique identifier (required)
version: "1.0.0"             # Semantic version (required)
type: "tool" | "routine"     # Extension type (required)
entry_point: "src.plugin"    # Python module path (required)
dependencies:                # Optional: External pip packages
  - "requests>=2.28.0"
  - "beautifulsoup4"
requires_services:           # Optional: Service process dependencies
  - "runtime"                # Requires Runtime for LLM calls
  - "ui"                     # Requires UI for user interaction
metadata:                    # Optional: Display info
  author: "Developer Name"
  description: "Brief description"
  license: "MIT"

```

**Plugin Base Class (TDD):**

```python
|TDD-14| ← |ICD-19|, |FSD-18|: "Component: AbstractExtension"

from abc import ABC, abstractmethod
from typing import List, Dict, Any

class AbstractExtension(ABC):
    """
    Base class for all Tools and Routines.

    Implements
    ----------
    |TDD-14|, |FSD-3|

    Lifecycle
    ---------
    1. Core instantiates: ext = ExtensionClass()
    2. Core initializes: ext.initialize(core_context)
    3. Core queries: states = ext.get_hsm_states()
    4. Core registers: ext event handlers with HSM

    Attributes
    ----------
    core_context : CoreContext
        Injected dependency for Core services
    """

    @abstractmethod
    def initialize(self, core_context: Any) -> None:
        """
        Called once during Core startup.

        Parameters
        ----------
        core_context : CoreContext
            Provides access to:
            - core_context.send_to_service(service, command, payload)
            - core_context.logger (Loguru instance)
            - core_context.config (Dict from ipc_config.yaml)

        Implementation Notes
        --------------------
        - Load extension-specific configuration
        - Initialize internal state
        - Validate required services are available

        Raises
        ------
        RuntimeError
            If required service not available

        References
        ----------
        |FSD-18.4|, |TDD-4.2|
        """
        pass

    @abstractmethod
    def get_hsm_states(self) -> List[Dict[str, Any]]:
        """
        Return HSM state definitions for dynamic compilation.

        Returns
        -------
        List[Dict]
            State configuration dicts for transitions library

        Schema
        ------
        [
          {
            "name": "state_name",
            "parent": "busy",  # Optional: Nested state
            "on_enter": "method_name",  # Optional: Callback
            "on_exit": "method_name"    # Optional: Callback
          },
          ...
        ]

        Example
        -------
        Tool that adds "exporting" state under "busy":
        [
          {"name": "exporting", "parent": "busy", "on_enter": "start_export"}
        ]

        References
        ----------
        |FSD-18.5|, |FSD-2.2|, |TDD-4.3|
        """
        pass

    @abstractmethod
    def handle_event(self, event_data: Dict[str, Any]) -> str:
        """
        Process business logic for extension-specific events.

        Parameters
        ----------
        event_data : dict
            Event payload from Core, structure:
            {
              "event_type": "user_command" | "service_response" | "timer",
              "command": str,  # If user_command
              "response": dict,  # If service_response
              "request_id": str
            }

        Returns
        -------
        str
            Next HSM trigger to fire (e.g., "to_idle", "to_error")

        Implementation Notes
        --------------------
        - Inspect event_data["event_type"]
        - Execute tool/routine logic
        - Call core_context.send_to_service() for IPC
        - Return appropriate HSM trigger

        Error Handling
        --------------
        - Raise exceptions for unrecoverable errors (Core logs + error state)
        - Return "to_error" trigger for graceful error handling

        References
        ----------
        |FSD-18.6|, |TDD-4.4|
        """
        pass

```

----------

### 20.3 Performance Profiling Documentation

When optimizing performance, document both targets and measurement methodology.

**Performance Requirements (NFR):**

```
|NFR-17| ← |BRD-8|: "Performance Profiling & Optimization"
  |NFR-17.1|: Instrumentation overhead: <1% CPU, <10MB RAM.
  |NFR-17.2|: Metrics collection frequency: Every 100ms (non-blocking).
  |NFR-17.3|: Metrics storage: Rolling buffer, last 1 hour of data.
  |NFR-17.4|: Metrics visualization: Real-time dashboard (optional UI tab).
  |NFR-17.5|: Exportable reports: JSON export for offline analysis.

```

**Profiling Features (FSD):**

```
|FSD-19| ← |NFR-17|: "Performance Monitoring"
  |FSD-19.1|: Core tracks per-request latency breakdown:
    - IPC routing time
    - Service processing time (STT, LLM, TTS)
    - Queue wait time
  |FSD-19.2|: Services report GPU/CPU utilization every 100ms.
  |FSD-19.3|: Memory profiler tracks per-process RSS/VRAM usage.
  |FSD-19.4|: UI displays real-time metrics:
    - Current FPS (UI responsiveness)
    - LLM tokens/second
    - Audio buffer health (underrun/overrun count)
  |FSD-19.5|: Admin command: "/metrics export" → saves JSON to ./logs/metrics_{timestamp}.json.

```

**Metrics Schema (ICD):**

```json
|ICD-20| ← |FSD-19.1|: "Performance Metrics Schema"
{
  "timestamp": "ISO-8601",
  "request_id": "uuid",
  "latency_breakdown": {
    "total_ms": 1234.5,
    "ipc_routing_ms": 2.1,
    "stt_processing_ms": 450.0,
    "llm_inference_ms": 780.0,
    "tts_synthesis_ms": 2.4
  },
  "resource_usage": {
    "core_process": {"cpu_percent": 5.2, "rss_mb": 45},
    "runtime_process": {"cpu_percent": 85.0, "rss_mb": 3200, "vram_mb": 4800},
    "ui_process": {"cpu_percent": 12.0, "rss_mb": 180}
  },
  "queue_stats": {
    "core_queue_size": 3,
    "runtime_queue_size": 1,
    "max_wait_time_ms": 15.0
  }
}

```

----------
