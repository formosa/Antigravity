# MAGGIE Development Documentation Roadmap (DDR) Types

## 1. Business Requirements (Context)
* **Abbreviation:** BRD
* **Type:** Strategic Context & Scope
* **Assigned Persona:** Strategist
* **Data Flow:** Intent → Goals
* **Purpose:** To serve as the strategic anchor, defining the "Why" and high-level "What" of the project without touching on technical implementation.
* **Explanation:**
    * **Content:** Contains the Project Purpose, Business Rationale (e.g., privacy, offline capability), and Success Metrics (e.g., latency targets). It establishes the problem statement and the scope of the solution.
    * **Industry Role:** Acts as the primary agreement between stakeholders and the engineering team, ensuring the product built aligns with business value.
    * **Distinction:** Unlike the FSD or TDD, the BRD is solution-agnostic. It focuses purely on *value* and *outcomes* rather than functionality or code structure.

## 2. System Constraints (Boundaries)
* **Abbreviation:** NFR
* **Type:** Non-Functional Requirements
* **Assigned Persona:** SysAdmin
* **Data Flow:** Hardware → Constraints
* **Purpose:** To define the "How Well" and "Where," establishing hard limits on hardware, security, and performance.
* **Explanation:**
    * **Content:** Specifies target environment limits (e.g., GPU VRAM, CPU models), resource isolation rules (memory footprints), and critical performance thresholds (e.g., <1ms IPC dispatch).
    * **Industry Role:** Defines the "Quality Attributes" (reliability, efficiency, security) that architects must design around. It prevents "functional but unusable" software.
    * **Distinction:** It defines *constraints*, not features. While the FSD describes *what* the system does, the NFR dictates the *physics* (speed, size, security) of how it must operate.

## 3. Feature Specifications (Behavior)
* **Abbreviation:** FSD
* **Type:** Functional Behavior & Capabilities
* **Assigned Persona:** Product Owner
* **Data Flow:** Requirements → Capabilities
* **Purpose:** To describe the detailed functional "What," acting as the contract for system behavior and user experience.
* **Explanation:**
    * **Content:** Details the Process Orchestration, Voice Interaction Pipeline (Wake Word, VAD), and Logic Flows (Intent Resolution). It maps user inputs to system actions.
    * **Industry Role:** Bridges the gap between business needs and technical design, serving as the primary reference for QA testing and user acceptance.
    * **Distinction:** It describes *logic flow* and *behavior*, but not the underlying code structure (TDD) or data wire formats (ICD). It tells you what the button does, not how the code behind it is written.

## 4. Architecture Definitions (Structure)
* **Abbreviation:** SAD
* **Type:** System Architecture & Topology
* **Assigned Persona:** Architect
* **Data Flow:** Features → Patterns/Topology
* **Purpose:** To define the high-level "How," mapping out process topology, communication patterns, and concurrency models.
* **Explanation:**
    * **Content:** Visualizes the "Hub-and-Spoke" process topology, defines IPC patterns (ROUTER-DEALER, PUSH-PULL), and establishes concurrency strategies (Priority Queues).
    * **Industry Role:** Provides the "30,000-foot view" necessary for understanding system complexity, scalability, and integration points before code is written.
    * **Distinction:** Focuses on the *relationships* between components and the *flow* of data, whereas TDD focuses on the internal anatomy of the components themselves.

## 5. Interface & Data Schemas (Contracts)
* **Abbreviation:** ICD
* **Type:** Interfaces & Data Protocols
* **Assigned Persona:** Data Engineer
* **Data Flow:** Topology → JSON/Schemas
* **Purpose:** To define the "Wire" and the "Data," creating strict contracts for data exchange between decoupled processes.
* **Explanation:**
    * **Content:** Contains strict definitions for Configuration Schemas (`ipc_config.yaml`), Message Frame Structures, and JSON Metadata payloads.
    * **Industry Role:** Essential in distributed systems to ensure interoperability. It prevents integration failures by enforcing rigid data shapes at the boundaries.
    * **Distinction:** Purely declarative. It contains no business logic (FSD) or implementation code (TDD), only the structure of the data moving between them.

## 6. Technical Design (Blueprints)
* **Abbreviation:** TDD
* **Type:** Component Blueprints
* **Assigned Persona:** Lead Developer
* **Data Flow:** Contracts → Class Structure
* **Purpose:** To define the low-level "How," translating architecture and contracts into specific software component designs.
* **Explanation:**
    * **Content:** Provides Class Blueprints (e.g., `CoreProcess`, `ServiceClient`), dependency lists, method signatures, and specific socket configurations.
    * **Industry Role:** Serves as the immediate precursor to coding, giving developers a clear plan of attack for internal class structure and logic encapsulation.
    * **Distinction:** Granular and code-centric. Unlike the SAD (which connects processes), the TDD defines the internal organs of the process itself, but stops short of writing the actual code.

## 7. Implementation Stubs (Prompts)
* **Abbreviation:** ISP
* **Type:** Code Scaffolding & Prompts
* **Assigned Persona:** Code Generator
* **Data Flow:** Blueprints → Python Stubs
* **Purpose:** To provide the "Starter Code," offering executable scaffolds and docstrings to accelerate implementation.
* **Explanation:**
    * **Content:** Contains actual Python code blocks, import statements, class skeletons, and docstrings that explicitly reference upstream requirements.
    * **Industry Role:** Facilitates Test-Driven Development (TDD) or AI-assisted coding by providing context-aware starting points that are already aligned with the architecture.
    * **Distinction:** The only document type containing executable programming language syntax. It is the realization of the TDD blueprints into actual code artifacts.